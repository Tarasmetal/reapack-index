#!/usr/bin/env ruby

Signal.trap('INT') { abort }

require 'reapack/index'

require 'git'
require 'io/console'

def prompt(question, &block)
  print "#{question} [y/N]"
  answer = STDIN.getch
  puts

  yes = answer.downcase == 'y'
  block[] if block_given? && yes

  yes
end

def scan(db, path, contents)
  db.scan path, contents
rescue RuntimeError => e
  warn "Warning: #{e.message}"
  abort unless prompt "Continue?"
end

git = Git.open ARGV.first || Dir.pwd
db = ReaPack::Index.new File.join(git.dir.to_s, 'index.xml')
db.source_pattern = ReaPack::Index.source_for git.remote.url

if git.current_branch != 'master'
  abort unless prompt("Current branch #{git.current_branch} is not" \
    " the master branch. Continue?")
end

commits = nil

if db.commit
  commits = git.log(999999).between db.commit
else
  commits = git.log 999999
end

commits.reverse_each {|commit|
  puts "Processing #{commit.message.lines.first.chomp} (#{commit.sha[0..6]})..."

  db.commit = commit.sha
  parent = commit.parent

  # initial commit
  unless parent
    commit.gtree.files.each_pair {|path, blob|
      next unless ReaPack::Index.type_of path

      puts "-> indexing new file #{path}"
      scan db, path, blob.contents
    }
    next
  end

  Git::Diff.new(git, commit.parent.sha, commit.sha).each {|diff|
    next unless ReaPack::Index.type_of diff.path

    puts "-> indexing #{diff.type} file #{diff.path}"

    if diff.type == 'deleted'
      db.delete diff.path
    else
      scan db, diff.path, diff.blob.contents
    end
  }
}

puts

if db.modified?
  changelog = db.changelog
  puts changelog

  prompt 'Write changes and commit the new database?' do
    db.write!

    # git.add 'index.xml'
    # git.commit changelog

    puts 'done'
  end
else
  puts 'The database was not modified!'
end
